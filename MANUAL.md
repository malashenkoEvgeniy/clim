Laravel
---

Большая часть документации находится на [оф. сайте фреймворка](https://laravel.com) или на
[Laravel по-русски](https://laravel.ru/).

Интересные факты, которые также есть в документации, но их можно упустить описаны в
[этой статье](https://laravelnews.ru/20-khitrostey-v-laravel-eloquent-o-kotorykh-vy-ne-znali).

E-commerce
---

Особенности e-commerce описаны ниже (структура папок, основные компоненты, логика создания модуля и другие).

В e-commerce мы разделяем все элементы на два типа: глобальные и локальные (элементы для конкретного
разрабатываемого модуля). В дальнейшем в этом разрезе и будет описана вся документация.

Локальные елементы необходимо размещать внутри нуждающихся в них модулей. Рекомендуется папку для локальных
компонентов называть также как называется глобальная (Components, Traits, Widgets etc.).

Разделение на админ панель и клиентскую часть сайта выполняем в едином стиле. Групповая папка для сайта
называется Site, а для админ панели - Admin. Если необходимо создать еще одну глобальную роль на ряду с
пользователями и администраторами (например, для брачных агентств требуется админ панель агентства со
своей системой администраторов), то просто создаем еще одну папку (например, Agency).

Структура папок внутри папки 'app'
---

#### Components

Папка содержит основные рабочие компоненты. Большинство компонентов, которые идут из коробки используются только
для админ панели.

В этой папке будут располагаться глобальные компоненты.

#### Core

Название папки четко описывает ее функциональность. Тут находятся: базовые контроллеры для клиентской части сайта
и админ панели; базовый класс абстрактный BaseProvider, от которого наследуются все ServiceProvider'ы модулей;
общий базовый контроллер; сюда же перенесен Kernel.php; также тут распологается ряд модулей "из коробки" (они
будут описаны ниже).

#### Helpers

Как и следует из названия, тут будут располагаться классы-помощники, а также файлы с глобальными методами.

Для того, что бы зарегистрировать файл с методами, необходимо обратиться к файлу composer.json, добавив в
массив autoload.files путь к вашему файлу.

#### Rules

Тут располагаются кастомные валидационные правила. По работе с ними обратитесь к оф. документации.

#### Traits

Глобальные трейты. Почитать, что это такое можно [тут](http://php.net/manual/ru/language.oop5.traits.php).

Предустановленные трейты будут описаны ниже.

#### Widgets

Тут находятся глобальные виджеты сайта и админ панели.

#### Modules

Это самая важная папка. Та, в которой будет проходить 90% работы. Тут находятся папки всех модулей проекта.
Каждый модуль содержит в себе всю необходимую для работы информацию. По сути, удаляя один из модулей, проект
должен продолжать безошибочно работать. Это самая сложная задача в e-commerce, но инструмент для ее реализации
дан.

Структура модуля
---

Каждый модуль может состоять из множества файлов и папок. В этом разделе описаны самые важные элементы.
Остальные (например Widgets, Components etc.) могут отсутствовать или быть названы иначе, это не принципиально
важно, хотя рекомендовано не путать других разработчиков и называть все одинаково.

#### Provider.php

Это единственный файл, который обязателен для создания и подключения нового модуля, хотя лишь на нем далеко
не уедешь. Подробно возможности данного элемента будут описаны ниже.

#### Controllers

Собственно, контроллеры нашего модуля. Папка разделяетя на типы приложений (Admin, Site). Каждый контроллер
описывает необходимый набор действий. Рекомендовано использовать стандартные названия для методов контроллера
(index, deleted, show, create, store, edit, update, destroy, restore).

Также у каждого контроллера существуют методы active (для изменения активности элемента), sortable (для
сортировки строк). Для того, что бы метод заработал необходимо лишь добавить роут.

Очень желательно по минимуму отсутпать от стандартных названий, так как по них уже все написано и не придется
искать как заставить работать новыми экшны. Но при необхожимости данная задача легко решается.

#### Database

Работа с базой данных. В ней могут содержаться еще две папки:
- Migrations: тут будут лежать миграции текущего модуля;
- Seeds: тут лежат сидеры, если это необходимо.

#### I18n

Папка дублирует содержимое папки resources/lang и содержит в себе все статические переводы модуля. Важно
не использовать переводы других модулей.

#### Models

Одна из самых важных папок. Тут находятся все модели модуля.

#### Routes

В этой папке может находиться 2 файла:
- admin.php для роутов админ панели;
- site.php для роутов сайта.

#### Views

Представления сайта и админ панели. Просьба разделять папку на admin и site внутри для лучшего поиска
шаблонов.

#### Forms

Тут находятся настройки форм текущего модуля. Настройка возможно благодаря компоненту Form.

#### Filters

Тут находятся настройки формы фильтра текущего модуля. Настройка возможно благодаря компоненту Form.

#### Requests

В данной папке находятся настройки обработчиков входящего запроса с форм. Тут же указывается валидация,
которая автоматически применится к экшну.

Модули "из коробки"
---

"Чистая" e-commerce, по сути, является самостоятельным работоспособным продуктом. Предустановленные модуля
находятся в папке `app\Core\Modules`. Удалять их нельзя, иначе ляжет все. Эти модуля нужны всегда для
корректной работы продукта.Тут находятся настройки форм текущего модуля. Настройка возможно благодаря компоненту Form.

В подавляющем количестве случаев, в эти модуля не будет необходимости лезть.

#### Dashboard

Модуль необходим для отображения стартовой страницы админ панели.

#### Mail

Модуль шаблонов писем. Сам модуль является хранилищем для обработки данных. Сами данные туда должны попадать извне.
Пример решения задачи - добавить в сидер конкретного модуля нужные данные о письмах. Соответственно, при запуске сидеров,
таблица будет наполняться нужными записями, а вы будете знать точный алиас письма.

Самый простой способ создания письма через консольную комманду `php artisan module:mail {ModuleName}`. Далее ответьте на
пару вопросов. После этого будут созданы все нужные файлы переводов, event, listener, seeder. При этом сидер
выполнится автоматически.

Для возможности использовать систему, вам необходимо зарегистрировать в своем Provider'е listener:
```php
Event::listen(YourEvent::class, YourListener::class);
```

После этого просто "зажечь" событие:

```php
// Так
Event::fire(new YourEvent('yourParameters'));
// ... или так
event(new YourEvent('yourParameters'));
```

#### Languages

Так как e-commerce по-умолчанию заточена под мультиязычность, то появилась необходимость в этом модуле.
Визуально благодаря ему появляется всего лишь одна страница - "Языки". На ней возможно поменять язык сайта
по-умолчанию.

**Внимание!** Язык по-умолчанию определяет у какой локализации не будет присутствовать часть `/lang` в УРЛ
адресе страницы. Изменение языка по-умолчанию приведет к изменению УРЛ адресов, что плохо повлияет на СЕО
продвижение сайта. Не нужно этого делать без необходимости.

#### Settings

Модуль настроек сайта. Каждая настройка в индивидуальном порядке описывается в соответствующем ServiceProvider'е.
Данный раздел позволяет гибко настроить администратору как сайт так и админ панель под себя.

#### Administrators

Раздел администрирования. Он содержит в себе:
- личный кабинет администратора;
- логику авторизации администратора;
- управление администраторами (только для суперадмина);
- управление ролями администраторов (только для суперадмина).

Модуль позволяет создавать администраторов и задавать им роли, а также определять возможности этих самых ролей.

Возможности присваемые ролям по каждому модулю жестко заданы и могут принимать следующие значения:
- `index`: просмотр списков (активные, удаленные и т.д.);
- `view`: подробный просмотр элемента;
- `store`: создание (также влияет на возможность восстановить элемент из удаленных);
- `update`: редактирование (используется для многих кнопок, других виджетов);
- `delete`: удаление.

#### Crop

Раздел содержит в себе функционал кропа изображений. Использование предельно просто. Если в форме есть загрузка
изображения и в настройках указана возможность кропнуть фото, то при редактировании появится кнопка для
перехода на страницу кропа текущего изображения.

Создание собственного модуля
---

- Открываем консоль.
- Печатаем `php artisan module:create <YourModuleName>`.
- Отвечем на поставленные впросы.

Далее необходимо найти в файле `config/app.php` свойство 'providers' и дописать в него строчку:

```php
'providers' => [
    ......
    path\to\your\Provider::class,
    ......
],
```

Порядок добавления сервис провайдеров в список важен. Он определяет порядок подключения компонентов и
порядок регистрации их элементов.

Содержимое пустого Provider.php:

```php
<?php namespace App\Modules\MyModule;

use App\Core\BaseProvider;

class Provider extends BaseProvider
{
    protected function presets() {}
}

```

Вот и все. Модуль подключен и готов к настройке. Большая часть из них прописывается внутри Provider.php.

Настройка модуля в Provider.php
---

Как уже было сказано этот файл является точкой входа в модуль и является самой важной его частью. Тут можно
настроить такие элементы как:
- Пути к папкам, где искать представления, роутинг, миграции, переводы и другие составляющие модуля;
- Регистрация неизменяемых пунктов меню (например левое меню в админ панели или меню пользователя на сайте);
- Прописать правила для работы системы ролей;
- Добавить элементы на страницу настроек;
- Зарегистрировать виджеты модуля;
- многое другое.

Ниже представлен ряд методов, которые можно переопределить.

#### protected function presets()

Данный метод **должен быть переопределен**, хотя может оставаться пустым. Он вызывается еще до загрузки модуля
и используется в основном для переопределения базовых элементов таких как:
- Название модуля: `setModuleName()`. По умолчанию snake case названия папки модуля.
- Название области видимости для поиска представлений: `setViewNamespace()`. Используется так:
`view('namespace::template')`. По умолчанию snake case названия папки модуля.
- Путь к главной папке контроллеров: `setRouteNamespace()`. Необходимо передать пути вида
`App\Modules\Controllers`. Передать можно любой удобный путь. По умолчанию используется папака Controllers
внутри модуля.
- Значение аналогичное контроллерам, но ведет к папке с сидерами: `setSeedersNamespace()`. По умолчанию
устанавливает значение `App\Modules\ModuleName\Database\Seeds`.
- Устанавливает элемент для вызова настроек: `setConfigNamespace()`. По умолчанию snake case названия папки
модуля. Можно использовать например так: `config('namespace.path.to.setting')`. Все эти настройки лежат в файле
`path/to/module/config/config.php`. Файл может отсутствовать, если в нем нет необходимости. По сути тут должны
располагаться не контроллируемые администратором внутренние настройки модуля.
- Устанавливает область видимости для переводов статических элементов модуля: `setTranslationsNamespace()`. По
умолчанию snake case названия папки модуля. Использовать можно например так: `__('namespace::path.to.translate')`.
- Устанавливает папку для поиска вложенных папок миграций (Migrations) и сидеров (Seeds): `setDatabaseFolder()`.
По умолчанию `app/Modules/ModuleName/Database`.
- Устанавливает путь к папке, где лежат представления: `setViewPath()`. По умолчанию это `app/Modules/ModuleName/Views`.
- Устанавливает путь к папке с роутами: `setRoutePath()`. В систему вшит поиск файлов `site.php` и `admin.php`.
В роутах для сайта уже учтена мультиязычность и описывать роуты для каждого языка нет необходимости. По
умолчанию это `app/Modules/ModuleName/Routes`.
- Устанавливает путь к папке, где лежит файл config.php: `setConfigPath()`. По умолчанию `app/Modules/ModuleName`.
- Устанавливает путь к папке, где лежат папки с локализацией:` setTranslationsPath()`. По умолчанию
это `app/Modules/ModuleName/I8n`.

#### protected function afterBootForAdminPanel()

Метод вызывается сразу в конце загрузки элементов, конфигурируемых предыдущим методом. Используется только
для админ панели. Тут можно регистрировать виджеты и их позиции для вывода, добавлять пункты меню, объявлять
возможности для ролей пользователей, добавлять администрируемые настройки модуля.

#### protected function afterBoot()

Метод аналогичный предыдущему, но используется только для сайта.

Предустановленные компоненты и их использование
---

#### Компонент _AdminRoleScope_ и разграничение прав администраторов

Компонент используется для ограничения прав _администраторов_, при этом суперадминистратор будет иметь
доступ ко всему. Количество суперадминистраторов неограничено, но создать их можно только напрямую в БД или
создав соответствующий сидер.

Работа модуля начинается с регистрации возможностей модуля в Provider.php.

```php
CustomRoles::add('module', 'module::translate');
```

CustomRoles - это фасад компонента для удобной работы с ним. В методе add() первым параметром передается
название модуля, вторым - название пункта в списке ролей или путь к его переводу (как в примере).

Регистрация элемента по средствам метожа add() вернет объект, который необходимо донастроить. Пример выше
не даст возможности выбрать настройки для компонента. Этим займутся такие методы как:
- `except($action, $action, $action,..)`: добавит все возможные параметры кроме указанных;
- `only($action, $action, $action,..)`: добавит все перечисленные параметры;
- `enableAll()`: добавит все возможные параметры;
- `disableAll()`: уберет из списка все возможные параметры
- `turnOn($action, $action, $action,..)`: добавит все перечисленные параметры; 
- `turnOff($action, $action, $action,..)`: уберет все перечисленные параметры;

```php
CustomRoles::add('scope', 'module::translate')->except('index', 'store');
```

Для удобства и безошибочного ввода возможностей существуют константы в модели RoleRule предустановленного
модуля Administrators.

Список констант:
- RoleRule:INDEX;
- RoleRule:VIEW;
- RoleRule:STORE;
- RoleRule:UPDATE;
- RoleRule:DELETE;

Для того, чтобы задать область прав для того или иного роута, необходимо обернуть ваши объявления роутов:

```php
Route::middleware('permission:scope')->group(function () {
    ....
    Your routes
    ....
});
```

В данном случае на месте scope должно быть написано то же название что и при регистрации прав в Provider.php.
Но есть одно исключение - это `scope = superadmin`. В этом случае доступ к описанным внутри роутам может получить
только администратор с правами суперадмина.

Для проверки возможности администратора совершать то или иное действие используется метод `can()`. Его можно
использовать двумя способами:

```php
CustomRoles::can('scope', 'action')

// или

CustomRoles::can('scope.action')
```

Метод возвращает `true` или `false`. Внутри себя он использует метод модели Admin модуля Administrators:

```php
Auth::user()->hasPermissions('scope', 'action')
```

#### Компонент _CustomMenu_

Компонент используется для формирования статических меню на сайте и в админ панели. Яркий пример - это
основное меню слева для администратора.

Регистрация компонента происходит в Provider.php отдельно взятых модулей. Рассмотрим возможности
компонента.

###### Создаем экземпляр меню

```php
// Дефолтное использование
$menu = CustomMenu::get();
// Кастомное дополнительное меню
$menu = CustomMenu::get('my-menu');
```

###### Создаем группу элементов

```php
// Дефолтная группа. Нет необходимости в параметрах, если нет разделения меню по группам
$group = $menu->group();

// Следующая запись может быть полезна для визуального разделения одного меню на несколько частей
// Для разделения меню на группы, необходимо передать доп. параметры
// Для этого задаем блоку алиас и название. По умолчанию название равно алиасу и его можно упустить
$group = $menu->group($alias, $name);
```

###### Создание блоков контейнеров

```php
// Добавляем блок ссылок в группу
// $alias* - указатель на блок. Это важно, если есть необходимость группировать ссылки из разных модулей
// $name - название блока. Если пропустить, то ему присвоится значение в $alias
// $icon - иконка блока
// $position - позиция блока относительно остальных элементов группы
$block = $group->block($alias, $name, $icon, $position);

// Также блоки можно добавлять внутрь других блоков
$subBlock = $block->block($alias, $name, $icon, $position);
```

###### Создаем пункт меню в виде ссылки

```php
// Для создания ссылки необходимо передать ряд параметров:
// $name* - название на ссылке или I18n макрос
// $route* - Объект типа RouteObjectValue
// $icon - иконка возле текста
// $additionalRoutesForActiveDetect - массив названий роутов. Он указывает нужно ли выделять ссылку когда пользователь находится на этих страницах
$link = $group->link($name, $route, $icon, $additionalRoutesForActiveDetect);
$link = $block->link($name, $route, $icon, $additionalRoutesForActiveDetect);
```

###### Конфигурация ссылки

```php
// Устанавливаем позицию элемента в списке
$link->setPosition(int $position);

// Устанавливаем настройки доступа
// $scope = 'module.action', где module - это тоже значение что задается при регистрации возможностей ролей
// Без этого параметра будут взяты настройки по умолчанию, они генерируются из роута ссылки
$link->setPermissionScope(string $scope);

// Для того, что бы вывести элемент меню в любом случае используется следующее свойство
$link->setCanBeShowed(true);
// Для того, что бы в любом случае не показывать элемент используйте
$link->setCanBeShowed(false);

// Иногда не удобно прописывать $additionalRoutesForActiveDetect при создании ссылки
// Благодаря следующему методу можно сделать то же самое
$link->additionalRoutesForActiveDetect($route, $route, $route,..);
```

###### Информация по ссылке

```php
// Проверяем активна ли ссылка
$link->isActive();

// Проверяем можем ли мы показать эту ссылку в меню
$link->canBeShowed();
```

#### Компонент _CustomSettings_

Компонент регистрирует администрируемые настройки модуля.

```php
// $alias - указатель на блок настроек
// $name - название блока настроек, отображаемое администратору
// $position - позиция, относительно других блоков
$settings = CustomSettings::createAndGet(string $alias, string $name, int $position);

// Добавление пункта меню в блок меню
// $formElement - это объект типа CustomForm\Element компонента CustomForm
// $validationRules - массив валидационных правил, согласно документации Laravel
// $position - позиция относительно других пунктов
$settings->add($formElement, $validationRules, $position);
```

В дальнейшем данные настроек можно получить следующим образом:

```php
// setting-alias берется из того самого $formElement (аттрибут name элемента формы)
config('db.setting-group-alias.setting-alias');
```

#### Компонент _CustomForm_

Компонент для генерации форм. Важно помнить, что он не добавляет открывающий и закрывающий теги form.

Способ создания формы можно варьировать под свои предпочтения. Итак рассмотрим эти способы.

- Первый вариант использует только объекты

```php
// Создаем контейнер для хранения формы
$form = Form::create();

// Создаем блок полей
// $width - ширина блока от 1 до 12. По умолчанию 12
// $color - класс цвета. Список можно посмотреть внутри FieldSet::class
// $title - Заголовок блока, если его нужно показать
$fieldSet = $form->fieldSet(int $width, string $color, string $title);

// Для блоков с мультиязычными дланными используем другой метод
$fieldSet = $form->fieldSetForLang(int $width, string $color, string $title);

// Теперь можно добавлять элементы
// $formElement - объект наследуюемый от CustomForm\Element (например Input, Select, Toggle etc.)
$fieldSet->add(Element $formElement, Element $formElement,..)->add(Element $formElement,..);
```

- Второй вариант построен на массивах и комбинировании массивов с CustomForm\Element

```php
// Конфигурируем форму
$block = [
    'i18n' => true, // Указывает нужен ли для этого блока мультиязычный блок полей
    'width' => 7,
    'color' => FieldSet::COLOR_DEFAULT,
    'title' => 'My title',
    'elements' => [
        ['class' => Element::class, 'name' => 'name', 'label' => 'Название'],
        Element $formElement,
    ],
];

// Создаем Форму
// $object - наша модель для подтягивания информации в поля. Может быть null
$form = Form::createFromArray($object, $block, $block, $block,..);
```

#### Компонент _Widget_

Компонент ответственнен за создание, регистрацию и вывод виджетов в необходимые места. Глобальные виджеты
кладем в папки `app/Widgets/Admin` и `app/Widgets/Site`, локальные стараемся в те же папки, но в пределах
модуля.

Пример виджета:

```php
class MyCustomWidget { 

    protected $parameter;

    public function __construct($parameter)
    {
        $this->parameter = $parameter;
    }
    
    public function render($param)
    {
        // Выполняем необходимые действия: расчеты, выборку из БД
        return view('module::view');
    }
}
```

Для того, что бы виджет было возможно вызвать в любом шаблоне, его нужно зарегистрировать в Provider.php.

```php
// $widgetAlias - алиас виджета, через который он будет вызываться в дальнейшем в представлениях
Widget::register(MyCustomWidget::class, $widgetAlias);
```

В случае, когда нужно задать параметры в виджете еще при регистрации или, когда одного параметра мало,
делаем так:

```php
Widget::register(new MyCustomWidget($parameter1, $parameter2,..), $widgetAlias);
```

Выводим виджет на экран в blade шаблоне:

```php
{!! Widget::show('widgetAlias', 'param') !!}
{-- или --}
{!! Widget::widgetAlias('param') !!}
```

При регистрации виджета мы можем задать еще 2 параметра:
- название позиции (например 'header', 'left-sidebar' etc);
- порядковый номер для сортировки виджетов внутри позиции.

При таком подходе виджет необходимо регистрировать передавая в него объект во всех случаях, когда он
должен принимать параметры, а объявление позиции в шаблоне выглядит следующим образом:

```php
{!! Widget::position('position-name') !!}
```

#### Компонент _Seo_

Используется для того, что бы задать странице следующие параметры:
- Title
- H1
- Keywords
- Description
- Seo text
- Breadcrumbs

### Подключение зависимых модулей

Обычно подключение модуля заканчивается на описании в провайдере простых элементов типа "Настройки" и "Меню".
Но сущесвуют модули вне ядра, которые несут в себе дополнительные возможности, связывающие их с другими
модулями.

#### Комментарии

Помимо стандартных настроек, Provider.php модуля комментариев имеет приватное свойство $morphMap (массив). Оно
служит своеобразным мостом между модулем комментариев и остальными модулями. Например, для того, чтобы
подключить модуль комментариев к новостям необходимо добавить следующее внутрь $morphMap: `'news' => News::class,`.
Таким образом автоматически появится метод comments() в модели News::class, а также пункт в меню в админ панели.

Метод comments() является связью и может быть вызван как свойство, сделав выборку из БД всего лишь раз.

Для того что бы все зараотало корректно, также необходимо найти модель News::class и подключить в ней trait
`EloquentTentacle`, а также прописать пропущенные переводы.

### Отправка Email

Для теста отпаравки писем на локальной машине, предлагаю использовать сервис mailtrap.io. Регистрируемся (создаем
ящик) и вам предоставят SMTP настройки для работы отправки писем.

```php
// Пример простой отправки письма
$sender = App\Components\Sender\MailSender::init();
$result = $sender->send(
    'to-email',
    'subject',
    'text'
);
```